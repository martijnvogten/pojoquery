= Advanced Topics

This section covers more advanced features and usage patterns in PojoQuery.

== Inheritance Mapping

PojoQuery supports single-table inheritance using the `@SubClasses` and `@SubClass` annotations.

1.  Annotate the **base class** with `@Table` pointing to the table containing data for all subclasses.
2.  Annotate the **base class** with `@SubClasses`, specifying the `discriminator` column name and an array of `@SubClass` definitions.
3.  Each `@SubClass` annotation links a specific subclass (`value`) to its corresponding `discriminatorValue`.
4.  Define the subclasses extending the base class. Fields specific to subclasses must correspond to columns present in the single base table.

[source,java]
----
// Base class mapped to the 'person' table
@Table("person")
@SubClasses(
    discriminator = "person_type", // Discriminator column in 'person' table
    value = {
        @SubClass(value = Employee.class, discriminatorValue = "EMP"), // 'EMP' identifies Employee rows
        @SubClass(value = Customer.class, discriminatorValue = "CUST") // 'CUST' identifies Customer rows
    }
)
public abstract class Person {
    @Id Long id;
    String name;
    @FieldName("person_type") String type; // Field mapping to the discriminator column
    // Common fields...
}

// Employee subclass - fields map to columns in 'person' table
public class Employee extends Person {
    String department;
    BigDecimal salary;
}

// Customer subclass - fields map to columns in 'person' table
public class Customer extends Person {
    Integer loyaltyPoints;
}

// --- Querying ---
// Querying for the base class fetches instances of the correct subclass
List<Person> persons = PojoQuery.build(Person.class).execute(dataSource);

for (Person p : persons) {
    if (p instanceof Employee) {
        Employee emp = (Employee) p;
        System.out.println("Employee: " + emp.name + ", Dept: " + emp.department);
    } else if (p instanceof Customer) {
        Customer cust = (Customer) p;
        System.out.println("Customer: " + cust.name + ", Points: " + cust.loyaltyPoints);
    }
}

// You can also query directly for a subclass
List<Employee> employees = PojoQuery.build(Employee.class)
    .addWhere("employee.department = ?", "Sales") // Note: Alias might be 'employee' or 'person' depending on context
    .execute(dataSource);
----

== Streaming Large Result Sets

For queries returning many rows, use `executeStreaming()` to process results row-by-row, avoiding `OutOfMemoryError`.

[source,java]
----
PojoQuery<LogEntry> query = PojoQuery.build(LogEntry.class)
    .addWhere("log.timestamp > ?", oneHourAgo);

// Process stream using DataSource
try (Stream<LogEntry> stream = query.executeStreaming(dataSource).stream()) {
    long errorCount = stream
        .filter(entry -> "ERROR".equals(entry.level))
        .count();
    System.out.println("Found " + errorCount + " errors.");
}

// Alternative using DB helper for raw SQL streaming
DB.queryRowsStreaming(dataSource,
    SqlExpression.sql("SELECT id, message FROM huge_log WHERE level = ?", "WARN"),
    rowMap -> {
        // Process each row as a Map<String, Object>
        System.out.println("Warning ID: " + rowMap.get("id"));
    });
----

== Custom Joins and Conditions

Use `@Join` or `addJoin()` for joins not handled by `@Link` conventions. Use curly braces `{}` in `addWhere()` for alias resolution when referencing explicitly joined tables.

[source,java]
----
@Table("article")
@Join(type = JoinType.INNER, tableName = "category", alias = "cat", joinCondition = "article.category_id = cat.id")
public class ArticleWithCategory {
    @Id Long id;
    String title;
    // Need to map category fields explicitly if not using @Link
    @Select("cat.name") String categoryName;
}

// Querying with condition on joined table
List<ArticleWithCategory> techArticles = PojoQuery.build(ArticleWithCategory.class)
    .addWhere("{cat.name} = ?", "Technology") // Use alias from @Join
    .execute(dataSource);
----

== CRUD Operations

PojoQuery provides static helpers for basic Insert, Update, Delete.

*   **Insert:** `PojoQuery.insert(dataSource, entity)` or `DB.insert(...)`
    *   Handles single-table and multi-table inheritance inserts.
    *   Populates the `@Id` field if it's auto-generated.
*   **Update:** `PojoQuery.update(dataSource, entity)` or `DB.update(...)`
    *   Updates based on the `@Id` field(s).
    *   Handles multi-table inheritance updates.
    *   Respects `@NoUpdate`.
    *   Can optionally handle optimistic locking if the entity implements `HasVersion`.
*   **Delete:** `PojoQuery.delete(dataSource, entity)` or `PojoQuery.deleteById(dataSource, Class, id)`
    *   Deletes based on the `@Id` field(s).
    *   Handles multi-table inheritance deletes (deletes from all mapped tables).

[source,java]
----
// --- Insert ---
User newUser = new User();
newUser.firstName = "Jane";
newUser.lastName = "Doe";
newUser.email = "jane.doe@example.com";
PojoQuery.insert(dataSource, newUser); // newUser.id will be populated if auto-generated
System.out.println("Inserted user with ID: " + newUser.id);

// --- Update ---
User existingUser = repo.findById(newUser.id); // Fetch first
if (existingUser != null) {
    existingUser.email = "jane.d@example.com";
    int updatedRows = PojoQuery.update(dataSource, existingUser);
    System.out.println("Updated rows: " + updatedRows);
}

// --- Delete ---
PojoQuery.delete(dataSource, existingUser); // Delete by entity instance
// OR
PojoQuery.deleteById(dataSource, User.class, existingUser.id); // Delete by ID
----

== Transactions

Use `DB.runInTransaction()` for simple transaction management.

[source,java]
----
import java.sql.Connection;

DB.runInTransaction(dataSource, (Connection connection) -> {
    // Operations within this lambda run in a single transaction
    User user = new User();
    user.firstName = "Temp";
    PojoQuery.insert(connection, user); // Use the provided connection

    Account account = new Account();
    account.userId = user.id;
    account.balance = BigDecimal.ZERO;
    PojoQuery.insert(connection, account); // Use the provided connection

    // If no exception is thrown, the transaction commits automatically.
    // If an exception occurs, it rolls back automatically.
    return true; // Return value from the transaction lambda
});
----

== Custom DbContext

Create a `DbContext` instance to customize identifier quoting style.

[source,java]
----
// Use double quotes for identifiers (PostgreSQL, SQL Server standard)
DbContext customContext = new DbContext(DbContext.QuoteStyle.DOUBLE_QUOTES);

// Build queries using this context
PojoQuery<Product> productQuery = PojoQuery.build(customContext, Product.class);

String sql = productQuery.toSql(); // SQL will use "product"."id" etc.
----
