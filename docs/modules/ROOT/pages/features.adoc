= PojoQuery Features

PojoQuery offers a focused set of features for interacting with relational databases using POJOs.

== Core Concepts

*   **POJO-Driven Queries:** Define the structure of your desired result using Java classes (POJOs). PojoQuery uses reflection and annotations on these classes to generate SQL.
*   **View-Based Approach:** Think of your POJO classes as defining a _view_ of your data, specifying which tables to join and which columns to select.
*   **No Lazy Loading:** PojoQuery fetches all requested data eagerly in a single query. This avoids `LazyInitializationException` issues and simplifies object serialization and usage outside of a database session.
*   **Predictable SQL:** The generated SQL is designed to be clean, readable, and predictable, closely mirroring how you might write it manually.

== Key Features

*   **Automatic SQL Generation:** Generates `SELECT`, `JOIN`, `WHERE`, `GROUP BY`, and `ORDER BY` clauses based on POJO structure and annotations.
*   **Type-Safe Results:** Maps JDBC `ResultSet` rows directly to instances of your POJO classes.
*   **Convention-Based Relationship Mapping:** Automatically generates `JOIN` clauses for one-to-one, one-to-many, and many-to-many relationships based on field naming conventions (e.g., `author` field joins on `author_id` column). Use `@Link` only when you need to customize the join behavior.
*   **Customizable Mapping (`@Table`, `@FieldName`, `@Id`):** Control how classes and fields map to database tables and columns.
*   **Custom SQL Expressions (`@Select`):** Include calculated fields or use database functions directly in your result POJO using the `@Select` annotation.
*   **Custom Joins (`@Join`, `@Joins`):** Define complex or non-conventional join conditions explicitly.
*   **Aggregation (`@GroupBy`, `@Select`):** Easily perform aggregation queries by combining `@GroupBy` on the class and `@Select` with aggregate functions (e.g., `COUNT`, `SUM`, `MAX`) on fields.
*   **Inheritance Mapping (`@SubClasses`, `@SubClass`):** Supports single-table inheritance strategies using a discriminator column.
*   **Embedded Objects (`@Embedded`):** Map fields from a nested value object into columns of the parent entity's table, optionally with a prefix.
*   **Dynamic Columns (`@Other`):** Map multiple database columns starting with a specific prefix into a `Map<String, Object>` field in your POJO.
*   **Fluent Query API:** Build queries programmatically using methods like `addWhere()`, `addOrderBy()`, `setLimit()`, `addJoin()`, etc.
*   **Basic CRUD Operations:** Provides static helper methods in `PojoQuery` and `DB` for `insert`, `update`, and `delete` operations based on POJOs or raw SQL.
*   **Streaming API:** Process large result sets efficiently without loading all rows into memory using `executeStreaming()` or `DB.queryRowsStreaming()`.
*   **Transaction Management:** Basic transaction support via `DB.runInTransaction()`.
*   **Database Agnostic (with caveats):** Designed to work with standard SQL. Specific database functions or syntax might require adjustments. Tested primarily with MySQL, PostgreSQL, and HSQLDB.

== What PojoQuery is NOT

*   **A Full JPA Implementation:** It does not implement the Java Persistence API standard.
*   **A Lazy-Loading ORM:** It intentionally avoids lazy loading and the associated complexities (sessions, proxies).
*   **A Cache Provider:** It does not include a built-in second-level cache.

PojoQuery focuses on simplifying the process of fetching structured data from a relational database into Java objects based on the defined POJO "view".
