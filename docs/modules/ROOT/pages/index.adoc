= PojoQuery Documentation
:description: A lightweight Java library for working with relational databases using POJOs
:keywords: java, database, orm, pojo, sql
:page-partial:
:page-layout: base

image:logo_pojoquery.png[alt="PojoQuery Logo", width=200, height=200]

== What is PojoQuery?

PojoQuery is a lightweight Java library for working with relational databases that takes a different approach to Object-Relational Mapping (ORM). Instead of using Java classes as table definitions, PojoQuery uses them as *query definitions* that shape the result set. This simple yet powerful paradigm eliminates many common ORM problems while keeping your database access code clean and maintainable.

[.lead]
*The PojoQuery Difference:* Your Java classes define what you want to get from the database, not how data is stored, freeing you from the object-relational impedance mismatch.

== Key Features

[cols="1,3"]
|===
| Feature | Description

| *Type-safe queries* 
| Define queries using Java POJOs with full type safety and IDE support

| *Smart SQL generation* 
| Automatic SQL generation with optimized JOINs based on your POJO structure

| *Relationship mapping* 
| Easily map one-to-one, one-to-many, and many-to-many relationships

| *No session management* 
| No lazy loading, no proxies, no complex session tracking

| *Complete control* 
| Full access to customize SQL when needed while keeping the ORM advantages

| *Clean POJO model* 
| No need to extend base classes or implement interfaces

| *Multi-database support* 
| Works with MySQL, PostgreSQL, HSQLDB, and most JDBC-compliant databases

| *Inheritance mapping* 
| Support for table-per-subclass inheritance patterns

| *Embedded objects* 
| Map complex object structures to database tables with `@Embedded`

| *Dynamic columns* 
| Handle schemaless patterns with `@Other` for dynamic column mappings
|===

== Rationale

The main difference with conventional Object Relational Mapping (ORM) is that types (Java classes) do not double as table definitions but rather as *query definitions*. More precisely, the POJO defines the shape of the resultset. This implies that type definitions must be *cycle-free*. 

This principle is the key to avoiding lazy loading and other complexities of conventional ORM. See link:https://martijnvogten.github.io/2025/04/16/the-basic-mistake-all-orms-make-and-how-to-fix-it.html[this article] about model-driven ORM.

[quote, Martin Fowler]
____
The hardest part of building a software system is deciding what to build [...], not the actual implementation difficulties.
____

PojoQuery allows you to focus on the data you need for each use case rather than trying to shoehorn your domain model into database tables.

== Quick Example

This self-contained example demonstrates PojoQuery's core philosophy: POJOs define *what you want to retrieve*, not how data is stored. The `SchemaGenerator` creates tables from your POJOs, and then you can query them with automatic joins.

[source,java]
----
import org.hsqldb.jdbc.JDBCDataSource;
import org.pojoquery.*;
import org.pojoquery.annotations.*;
import org.pojoquery.schema.SchemaGenerator;
import javax.sql.DataSource;
import java.util.*;

public class BookstoreExample {

    // === Entity definitions (map to database tables) ===
    
    @Table("author")
    static class Author {
        @Id Long id;
        String name;
        String country;
    }

    @Table("book")
    static class Book {
        @Id Long id;
        String title;
        Integer year;
        Author author;  // PojoQuery infers 'author_id' foreign key column
    }

    @Table("review")
    static class Review {
        @Id Long id;
        Book book;      // PojoQuery infers 'book_id' foreign key column
        Integer rating;
        String comment;
    }

    // === Query definitions (shape of results you want) ===
    
    // A book with author AND all its reviews
    static class BookDetail extends Book {
        List<Review> reviews;
    }

    public static void main(String[] args) {
        // 1. Create an in-memory database
        DataSource db = createDatabase();

        // 2. Generate tables from entity classes
        SchemaGenerator.createTables(db, Author.class, Book.class, Review.class);

        // 3. Insert test data
        Author tolkien = new Author();
        tolkien.name = "J.R.R. Tolkien";
        tolkien.country = "UK";
        tolkien.id = PojoQuery.insert(db, tolkien);

        Book lotr = new Book();
        lotr.title = "The Lord of the Rings";
        lotr.year = 1954;
        lotr.author = tolkien;
        lotr.id = PojoQuery.insert(db, lotr);

        Review r1 = new Review();
        r1.book = lotr;
        r1.rating = 5;
        r1.comment = "A masterpiece!";
        PojoQuery.insert(db, r1);

        Review r2 = new Review();
        r2.book = lotr;
        r2.rating = 5;
        r2.comment = "Epic fantasy at its finest.";
        PojoQuery.insert(db, r2);

        // 4. Query with automatic joins - the POJO shape defines what you get!
        List<BookDetail> books = PojoQuery.build(BookDetail.class)
            .addWhere("{author}.country = ?", "UK")
            .execute(db);

        for (BookDetail book : books) {
            System.out.println(book.title + " by " + book.author.name);
            System.out.println("Reviews: " + book.reviews.size());
            for (Review review : book.reviews) {
                System.out.println("  ★" + review.rating + " - " + review.comment);
            }
        }
    }

    static DataSource createDatabase() {
        JDBCDataSource ds = new JDBCDataSource();
        ds.setUrl("jdbc:hsqldb:mem:bookstore");
        ds.setUser("SA");
        ds.setPassword("");
        DbContext.setDefault(DbContext.forDialect(DbContext.Dialect.HSQLDB));
        return ds;
    }
}
----

*Key insight:* `BookDetail` and `BookWithAuthor` both map to the same `book` table, but produce different result shapes. The POJO structure tells PojoQuery which JOINs to generate—no XML configuration, no lazy loading surprises.

== When to Use PojoQuery

* When you need to fetch complex, nested data structures with a single query
* When you want direct control over the SQL being generated
* When you need to create different "views" or projections of your data
* When you want to avoid the complexity of ORM session management
* In applications with complex read/query patterns but simple write operations
* When performance and predictability are priorities

== Getting Started

To begin using PojoQuery in your project, see our xref:getting-started.adoc[Getting Started] guide.

== Documentation Structure

* xref:getting-started.adoc[Getting Started] - Setup and basic usage
* xref:features.adoc[Features] - Overview of PojoQuery capabilities
* xref:annotations.adoc[Annotations] - Detailed reference for all annotations
* xref:query-building.adoc[Query Building] - Using the fluent API to construct queries
* xref:database-support.adoc[Database Support] - Information on supported databases and configuration
* xref:advanced-topics.adoc[Advanced Topics] - Inheritance, custom joins, streaming, and more
* xref:examples.adoc[Examples] - Practical code examples

== Building from Source

To build PojoQuery from the source code:

. *Prerequisites:* Ensure you have JDK 17 or later installed.
. *Clone the repository:*
+
[source,bash]
----
git clone https://github.com/martijnvogten/pojoquery.git
----
. *Navigate to the project directory:*
+
[source,bash]
----
cd pojoquery
----
. *Build with Maven Wrapper:*
+
--
* On Linux/macOS:
+
[source,bash]
----
./mvnw clean install
----
* On Windows:
+
[source,bash]
----
mvnw.cmd clean install
----
--

This will compile the code, run tests, and install the artifact into your local Maven repository.