= PojoQuery Documentation
:description: A lightweight Java library for working with relational databases using POJOs
:keywords: java, database, orm, pojo, sql
:page-partial:
:page-layout: base

image:logo_pojoquery.png[alt="PojoQuery Logo", width=200, height=200]

== What is PojoQuery?

PojoQuery is a lightweight Java library for working with relational databases that takes a different approach to Object-Relational Mapping (ORM). Instead of using Java classes as table definitions, PojoQuery uses them as *query definitions* that shape the result set. This simple yet powerful paradigm eliminates many common ORM problems while keeping your database access code clean and maintainable.

[.lead]
*The PojoQuery Difference:* Your Java classes define what you want to get from the database, not how data is stored, freeing you from the object-relational impedance mismatch.

== Key Features

[cols="1,3"]
|===
| Feature | Description

| *Type-safe queries* 
| Define queries using Java POJOs with full type safety and IDE support

| *Smart SQL generation* 
| Automatic SQL generation with optimized JOINs based on your POJO structure

| *Relationship mapping* 
| Easily map one-to-one, one-to-many, and many-to-many relationships

| *No session management* 
| No lazy loading, no proxies, no complex session tracking

| *Complete control* 
| Full access to customize SQL when needed while keeping the ORM advantages

| *Clean POJO model* 
| No need to extend base classes or implement interfaces

| *Multi-database support* 
| Works with MySQL, PostgreSQL, HSQLDB, and most JDBC-compliant databases

| *Inheritance mapping* 
| Support for table-per-subclass inheritance patterns

| *Embedded objects* 
| Map complex object structures to database tables with `@Embedded`

| *Dynamic columns* 
| Handle schemaless patterns with `@Other` for dynamic column mappings
|===

== Rationale

The main difference with conventional Object Relational Mapping (ORM) is that types (Java classes) do not double as table definitions but rather as *query definitions*. More precisely, the POJO defines the shape of the resultset. This implies that type definitions must be *cycle-free*. 

This principle is the key to avoiding lazy loading and other complexities of conventional ORM. See link:https://martijnvogten.github.io/2025/04/16/the-basic-mistake-all-orms-make-and-how-to-fix-it.html[this article] about model-driven ORM.

[quote, Martin Fowler]
____
The hardest part of building a software system is deciding what to build [...], not the actual implementation difficulties.
____

PojoQuery allows you to focus on the data you need for each use case rather than trying to shoehorn your domain model into database tables.

== Quick Example

This self-contained example demonstrates PojoQuery's core philosophy: POJOs define *what you want to retrieve*, not how data is stored. The `SchemaGenerator` creates tables from your POJOs, and then you can query them with automatic joins.

NOTE: Code examples use public fields for brevity. PojoQuery works equally well with private fields and JavaBean-style getters/setters.

[source,java]
----
include::example$test/examples/bookstore/BookstoreExample.java[]
----

*Key insight:* `BookDetail` and `BookWithAuthor` both map to the same `book` table, but produce different result shapes. The POJO structure tells PojoQuery which JOINs to generateâ€”no XML configuration, no lazy loading surprises.

== When to Use PojoQuery

* When you need to fetch complex, nested data structures with a single query
* When you want direct control over the SQL being generated
* When you need to create different "views" or projections of your data
* When you want to avoid the complexity of ORM session management
* In applications with complex read/query patterns but simple write operations
* When performance and predictability are priorities

== Getting Started

To begin using PojoQuery in your project, see our xref:getting-started.adoc[Getting Started] guide.

== Documentation Structure

* xref:getting-started.adoc[Getting Started] - Setup and basic usage
* xref:features.adoc[Features] - Overview of PojoQuery capabilities
* xref:annotations.adoc[Annotations] - Detailed reference for all annotations
* xref:query-building.adoc[Query Building] - Using the fluent API to construct queries
* xref:database-support.adoc[Database Support] - Information on supported databases and configuration
* xref:advanced-topics.adoc[Advanced Topics] - Inheritance, custom joins, streaming, and more
* xref:examples.adoc[Examples] - Practical code examples

== Building from Source

To build PojoQuery from the source code:

. *Prerequisites:* Ensure you have JDK 17 or later installed.
. *Clone the repository:*
+
[source,bash]
----
git clone https://github.com/martijnvogten/pojoquery.git
----
. *Navigate to the project directory:*
+
[source,bash]
----
cd pojoquery
----
. *Build with Maven Wrapper:*
+
--
* On Linux/macOS:
+
[source,bash]
----
./mvnw clean install
----
* On Windows:
+
[source,bash]
----
mvnw.cmd clean install
----
--

This will compile the code, run tests, and install the artifact into your local Maven repository.