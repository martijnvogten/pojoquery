package org.pojoquery.dialects;

import java.lang.reflect.Field;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.util.Date;
import java.util.Map;

import org.pojoquery.AnnotationHelper;
import org.pojoquery.DbContext;
import org.pojoquery.FieldMapping;
import org.pojoquery.pipeline.SimpleFieldMapping;

/**
 * DbContext implementation for HSQLDB (HyperSQL Database).
 * Uses no quoting for case-insensitive identifiers, but quotes aliases with ANSI style.
 * Ideal for testing and embedded database scenarios.
 */
public class HsqldbDbContext implements DbContext {

    @Override
    public Dialect getDialect() {
        return Dialect.HSQLDB;
    }

    @Override
    public QuoteStyle getQuoteStyle() {
        return QuoteStyle.NONE;
    }

    @Override
    public String quoteObjectNames(String... names) {
        StringBuilder ret = new StringBuilder();
        for (int i = 0; i < names.length; i++) {
            if (i > 0) {
                ret.append(".");
            }
            // No quoting - identifiers will be case-insensitive
            ret.append(names[i]);
        }
        return ret.toString();
    }

    @Override
    public String quoteAlias(String alias) {
        // Quote aliases with ANSI double quotes to preserve the dot separator
        // (e.g., "event.eventID") while keeping table/column names unquoted
        return "\"" + alias + "\"";
    }

    @Override
    public FieldMapping getFieldMapping(Field f) {
        return new SimpleFieldMapping(f);
    }

	@Override
	public String getForeignKeyColumnType() {
		return "BIGINT";
	}

    @Override
    public String mapJavaTypeToSql(Field field) {
        Class<?> type = field.getType();

        if (type == Long.class || type == long.class) {
            return "BIGINT";
        }
        if (type == Integer.class || type == int.class) {
            return "INT";
        }
        if (type == Short.class || type == short.class) {
            return "SMALLINT";
        }
        if (type == Byte.class || type == byte.class) {
            return "TINYINT";
        }
        if (type == Double.class || type == double.class) {
            return "DOUBLE";
        }
        if (type == Float.class || type == float.class) {
            return "FLOAT";
        }
        if (type == Boolean.class || type == boolean.class) {
            return "BOOLEAN";
        }
        if (type == BigDecimal.class) {
            AnnotationHelper.ColumnMetadata colMeta = AnnotationHelper.getColumnMetadata(field);
            int precision = (colMeta != null) ? colMeta.precision : 19;
            int scale = (colMeta != null) ? colMeta.scale : 4;
            return "DECIMAL(" + precision + "," + scale + ")";
        }
        if (type == BigInteger.class) {
            return "BIGINT";
        }

        if (type == String.class) {
            if (AnnotationHelper.isLob(field)) {
                return "CLOB";
            }
            AnnotationHelper.ColumnMetadata colMeta = AnnotationHelper.getColumnMetadata(field);
            int length = (colMeta != null) ? colMeta.length : getDefaultVarcharLength();
            return "VARCHAR(" + length + ")";
        }

        if (type == Date.class || type == LocalDateTime.class || type == Instant.class || type == java.sql.Timestamp.class) {
            return "TIMESTAMP";
        }
        if (type == LocalDate.class || type == java.sql.Date.class) {
            return "DATE";
        }
        if (type == LocalTime.class || type == java.sql.Time.class) {
            return "TIME";
        }

        if (type == byte[].class) {
            return "BLOB";
        }

        if (type.isEnum()) {
            return "VARCHAR(" + getDefaultVarcharLength() + ")";
        }

        // HSQLDB doesn't have native JSON, use CLOB
        if (Map.class.isAssignableFrom(type)) {
            return "CLOB";
        }

        return "VARCHAR(" + getDefaultVarcharLength() + ")";
    }

    @Override
    public String getAutoIncrementSyntax() {
        return "GENERATED BY DEFAULT AS IDENTITY (START WITH 1)";
    }

    @Override
    public String getCreateTableSuffix() {
        return "";
    }

    @Override
    public int getStreamingFetchSize() {
        return 0; // HSQLDB default
    }
}
