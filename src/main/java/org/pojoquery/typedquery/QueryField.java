package org.pojoquery.typedquery;

import java.util.Collection;
import java.util.Collections;

/**
 * Represents a type-safe reference to an entity field for use in queries.
 *
 * <p>QueryField instances are generated by the annotation processor and provide
 * compile-time safety for field references in queries. Each field knows its
 * column name, alias, and Java type.
 *
 * <p>Fields can create conditions directly using jOOQ-style methods:
 * <pre>{@code
 * Condition myth nameFilter = lastName.eq("Smith").or(lastName.eq("Johnson"));
 * new EmployeeQuery().where(nameFilter).list(connection);
 * }</pre>
 *
 * @param <E> the entity type this field belongs to
 * @param <T> the Java type of the field
 */
public class QueryField<E, T> {

    private final String alias;
    private final String columnName;
    private final String fieldName;
    private final Class<T> fieldType;

    /**
     * Creates a new QueryField.
     *
     * @param alias      the table alias (e.g., "employee")
     * @param columnName the database column name
     * @param fieldName  the Java field name
     * @param fieldType  the Java type of the field
     */
    public QueryField(String alias, String columnName, String fieldName, Class<T> fieldType) {
        this.alias = alias;
        this.columnName = columnName;
        this.fieldName = fieldName;
        this.fieldType = fieldType;
    }

    /**
     * Returns the table alias for this field.
     * @return the table alias
     */
    public String getAlias() {
        return alias;
    }

    /**
     * Returns the database column name.
     * @return the column name
     */
    public String getColumnName() {
        return columnName;
    }

    /**
     * Returns the Java field name.
     * @return the field name
     */
    public String getFieldName() {
        return fieldName;
    }

    /**
     * Returns the Java type of this field.
     * @return the field type
     */
    public Class<T> getFieldType() {
        return fieldType;
    }

    /**
     * Returns the fully qualified column reference (alias.column) wrapped in curly braces
     * for proper escaping by the query pipeline.
     * @return the qualified column reference
     */
    public String getQualifiedColumn() {
        return "{" + alias + "." + columnName + "}";
    }

    @Override
    public String toString() {
        return getQualifiedColumn();
    }

    // === Condition-building methods (jOOQ-style) ===

    /**
     * Creates an equality condition: field = value
     * @param value the value to compare
     * @return the condition
     */
    public Condition<E> eq(T value) {
        return new Condition<>(getQualifiedColumn() + " = ?", value);
    }

    /**
     * Creates a not-equal condition: field != value
     * @param value the value to compare
     * @return the condition
     */
    public Condition<E> ne(T value) {
        return new Condition<>(getQualifiedColumn() + " != ?", value);
    }

    /**
     * Creates an IS NULL condition.
     * @return the condition
     */
    public Condition<E> isNull() {
        return new Condition<>(getQualifiedColumn() + " IS NULL");
    }

    /**
     * Creates an IS NOT NULL condition.
     * @return the condition
     */
    public Condition<E> isNotNull() {
        return new Condition<>(getQualifiedColumn() + " IS NOT NULL");
    }

    /**
     * Creates a LIKE condition: field LIKE pattern
     * @param pattern the LIKE pattern
     * @return the condition
     */
    public Condition<E> like(String pattern) {
        return new Condition<>(getQualifiedColumn() + " LIKE ?", pattern);
    }

    /**
     * Creates a NOT LIKE condition.
     * @param pattern the LIKE pattern
     * @return the condition
     */
    public Condition<E> notLike(String pattern) {
        return new Condition<>(getQualifiedColumn() + " NOT LIKE ?", pattern);
    }

    /**
     * Creates an IN condition: field IN (values)
     * @param values the values to check against
     * @return the condition
     */
    public Condition<E> in(Collection<? extends T> values) {
        if (values == null || values.isEmpty()) {
            return Condition.alwaysFalse();
        }
        String placeholders = String.join(", ", Collections.nCopies(values.size(), "?"));
        return new Condition<>(getQualifiedColumn() + " IN (" + placeholders + ")", values.toArray());
    }

    /**
     * Creates an IN condition with varargs.
     * @param values the values to check against
     * @return the condition
     */
    @SafeVarargs
    public final Condition<E> in(T... values) {
        if (values == null || values.length == 0) {
            return Condition.alwaysFalse();
        }
        String placeholders = String.join(", ", Collections.nCopies(values.length, "?"));
        return new Condition<>(getQualifiedColumn() + " IN (" + placeholders + ")", values);
    }

    /**
     * Creates a NOT IN condition.
     * @param values the values to check against
     * @return the condition
     */
    public Condition<E> notIn(Collection<? extends T> values) {
        if (values == null || values.isEmpty()) {
            return Condition.alwaysTrue();
        }
        String placeholders = String.join(", ", Collections.nCopies(values.size(), "?"));
        return new Condition<>(getQualifiedColumn() + " NOT IN (" + placeholders + ")", values.toArray());
    }
}
