package examples.typedquery;

import static examples.typedquery.Employee_.email;
import static examples.typedquery.Employee_.firstName;
import static examples.typedquery.Employee_.hireDate;
import static examples.typedquery.Employee_.lastName;
import static examples.typedquery.Employee_.salary;

import java.sql.Connection;
import java.time.LocalDate;
import java.util.List;

import javax.sql.DataSource;

import org.hsqldb.jdbc.JDBCDataSource;
import org.pojoquery.DB;
import org.pojoquery.DbContext;
import org.pojoquery.PojoQuery;
import org.pojoquery.schema.SchemaGenerator;
import org.pojoquery.typedquery.Condition;

/**
 * Example demonstrating the typed query API generated by the annotation processor.
 *
 * <p>This example shows how to use the generated {@code EmployeeQuery} class and
 * static field references for type-safe, fluent queries.
 *
 * <p>Key features demonstrated:
 * <ul>
 *   <li>Type-safe WHERE conditions with {@code where(field).is(value)}</li>
 *   <li>Type-safe ORDER BY with {@code orderBy(field)}</li>
 *   <li>Fluent API chaining</li>
 *   <li>Efficient direct ResultSet mapping (no reflection)</li>
 * </ul>
 */
public class TypedQueryExample {

    public static void main(String[] args) {
        // Set up database context
        DbContext.setDefault(DbContext.forDialect(DbContext.Dialect.HSQLDB));

        DataSource dataSource = createDataSource();

        // Create tables
        SchemaGenerator.createTables(dataSource, Employee.class);

        // Run example in transaction
        DB.withConnection(dataSource, (Connection c) -> {
            // Insert test data
            insertTestData(c);

            // Example 1: Basic query with WHERE and ORDER BY
            System.out.println("=== Example 1: Find employees by email ===");

            Employee bob = new EmployeeQuery()
                .where(Employee_.email).is("bob@example.com")
                .where().email.like("%@example.com")
                .orderBy(Employee_.lastName)
                .first(c);
            System.out.println("Found: " + bob);
            System.out.println();

            // Example 2: Query with multiple conditions
            System.out.println("=== Example 2: Employees with salary > 50000, ordered by last name ===");
            List<Employee> highEarners = new EmployeeQuery()
                .where(salary).greaterThan(50000)
                .orderBy(lastName)
                .list(c);
            for (Employee emp : highEarners) {
                System.out.println("  " + emp.firstName + " " + emp.lastName + " - $" + emp.salary);
            }
            System.out.println();

            // Example 3: Using LIKE for pattern matching
            System.out.println("=== Example 3: Employees with last name starting with 'S' ===");
            List<Employee> smiths = new EmployeeQuery()
                .where(lastName).like("S%")
                .orderByAsc(firstName)
                .list(c);
            for (Employee emp : smiths) {
                System.out.println("  " + emp.firstName + " " + emp.lastName);
            }
            System.out.println();

            // Example 4: Between dates
            System.out.println("=== Example 4: Employees hired in 2023 ===");
            List<Employee> hiredIn2023 = new EmployeeQuery()
                .where(hireDate).between(LocalDate.of(2023, 1, 1), LocalDate.of(2023, 12, 31))
                .orderByDesc(hireDate)
                .list(c);
            for (Employee emp : hiredIn2023) {
                System.out.println("  " + emp.firstName + " " + emp.lastName + " - hired " + emp.hireDate);
            }
            System.out.println();

            // Example 5: Using IN clause
            System.out.println("=== Example 5: Find specific employees by first name ===");
            List<Employee> specific = new EmployeeQuery()
                .where(firstName).in("Alice", "Bob", "Charlie")
                .orderBy(lastName)
                .list(c);
            for (Employee emp : specific) {
                System.out.println("  " + emp.firstName + " " + emp.lastName);
            }
            System.out.println();

            // Example 6: Using findById
            System.out.println("=== Example 6: Find by ID ===");
            Employee byId = new EmployeeQuery().findById(c, 1L);
            System.out.println("Found by ID 1: " + byId);
            System.out.println();

            // Example 7: Chaining multiple where conditions
            System.out.println("=== Example 7: Multiple conditions (AND) ===");
            List<Employee> filtered = new EmployeeQuery()
                .where(salary).greaterThanOrEqual(60000)
                .where(lastName).like("%s%")
                .orderByDesc(salary)
                .limit(5)
                .list(c);
            System.out.println("Found " + filtered.size() + " matching employees");
            for (Employee emp : filtered) {
                System.out.println("  " + emp.firstName + " " + emp.lastName + " - $" + emp.salary);
            }
            System.out.println();

            // Example 8: Show generated SQL
            System.out.println("=== Example 8: View generated SQL ===");
            String sql = new EmployeeQuery()
                .where(email).like("%@example.com")
                .orderBy(lastName)
                .limit(10)
                .toSql();
            System.out.println("Generated SQL:");
            System.out.println(sql);
        });

        System.out.println("\nTypedQuery example completed successfully!");
    }

    private static void insertTestData(Connection c) {
        // Insert test employees
        String[] firstNames = {"Alice", "Bob", "Charlie", "Diana", "Edward", "Fiona", "George", "Helen"};
        String[] lastNames = {"Anderson", "Brown", "Clark", "Smith", "Jones", "Wilson", "Stevens", "Adams"};
        int[] salaries = {55000, 62000, 48000, 75000, 58000, 82000, 67000, 51000};
        LocalDate[] hireDates = {
            LocalDate.of(2022, 3, 15),
            LocalDate.of(2023, 1, 10),
            LocalDate.of(2021, 7, 22),
            LocalDate.of(2023, 6, 1),
            LocalDate.of(2020, 11, 30),
            LocalDate.of(2023, 9, 15),
            LocalDate.of(2022, 5, 8),
            LocalDate.of(2019, 2, 14)
        };

        for (int i = 0; i < firstNames.length; i++) {
            Employee emp = new Employee();
            emp.firstName = firstNames[i];
            emp.lastName = lastNames[i];
            emp.email = firstNames[i].toLowerCase() + "@example.com";
            emp.salary = salaries[i];
            emp.hireDate = hireDates[i];
            PojoQuery.insert(c, emp);
        }

        System.out.println("Inserted " + firstNames.length + " test employees\n");
    }

    private static DataSource createDataSource() {
        JDBCDataSource ds = new JDBCDataSource();
        ds.setUrl("jdbc:hsqldb:mem:typed_query_example");
        ds.setUser("SA");
        ds.setPassword("");
        return ds;
    }
}
